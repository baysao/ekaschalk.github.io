<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Emacs Lisp on Modern Emacs</title>
    <link>https://ekaschalk.github.io/categories/emacs-lisp/</link>
    <description>Recent content in Emacs Lisp on Modern Emacs</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2017 Eric Kaschalk</copyright>
    <lastBuildDate>Fri, 13 Oct 2017 00:00:00 +0000</lastBuildDate>
    <atom:link href="/categories/emacs-lisp/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Emacs-lisp exercises and solutions</title>
      <link>https://ekaschalk.github.io/post/elisp-exercises/</link>
      <pubDate>Fri, 13 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>https://ekaschalk.github.io/post/elisp-exercises/</guid>
      <description>&lt;p&gt;I present exercises ordered by aspect and difficulty with the intent of making
more tangible the Emacs slogan &#34;the infinitely customizable editor&#34;.&lt;/p&gt;

&lt;p&gt;Be familiar with:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Lisp syntax.&lt;/li&gt;
&lt;li&gt;Emacs help facilities like &lt;code&gt;describe-function&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;To learn:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;How to work with Emacs &lt;code&gt;rx&lt;/code&gt; macro for regexes.&lt;/li&gt;
&lt;li&gt;Traverse buffers and org-mode.&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;the-basics&#34;&gt;The basics&lt;/h1&gt;

&lt;h2 id=&#34;regexes-and-the-rx-macro&#34;&gt;Regexes and the rx macro&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;rx&lt;/code&gt; macro makes maintaining and writing regexes enjoyable and easy.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;match-beginning&lt;/code&gt; and &lt;code&gt;match-end&lt;/code&gt; are Emacs facilities for extracting regex
matches for particular groups.&lt;/p&gt;

&lt;p&gt;Solve the following exercises with the &lt;code&gt;rx&lt;/code&gt; syntax.&lt;/p&gt;

&lt;p&gt;Q1 (E) - Match the string in an org-mode header of any level.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;
(rx (1+ &amp;quot;*&amp;quot;)
    space
    (group (0+ not-newline)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There is the &lt;code&gt;group-n&lt;/code&gt; construct for specifying the group of a particular
particular part of the regex.&lt;/p&gt;

&lt;p&gt;Q2 (E) - Match both the string and the level of an org-mode header.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;
(rx (group-n 1 (1+ &amp;quot;*&amp;quot;))
    space
    (group-n 2 (0+ not-newline)))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;org-mode&#34;&gt;Org-mode&lt;/h2&gt;

&lt;p&gt;Q1 (E) - Get the heading name string above the current point.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;
(defun ex-current-heading ()
  (org-previous-visible-heading 1)
  (re-search-forward (rx (1+ &amp;quot;*&amp;quot;) space))
  (buffer-substring (point) (line-end-position)))
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Anonymous function macro in elisp</title>
      <link>https://ekaschalk.github.io/post/xi-macro/</link>
      <pubDate>Fri, 23 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://ekaschalk.github.io/post/xi-macro/</guid>
      <description>&lt;p&gt;Clojure has anonymous functions with the reader macro &lt;code&gt;#(&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;
(#(print %2 %1) &amp;quot;there&amp;quot; &amp;quot;hi&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Emacs Lisp doesn&#39;t have reader macros, but we can take direction from Hylang, a
lisp dialect similar to Clojure inter-oping with Python.&lt;/p&gt;

&lt;p&gt;It implements the anonymous functions as the aptly named &lt;code&gt;xi&lt;/code&gt; macro, where the
lambda has arguments determined by presence of &lt;code&gt;x1 ... xi&lt;/code&gt; .&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;
((xi print x2 x1) &amp;quot;there&amp;quot; &amp;quot;hi&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can implement the &lt;code&gt;xi&lt;/code&gt; macro in Emacs Lisp roughly as:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;
(require &#39;dash)
(require &#39;s)

(defmacro xi (&amp;amp;rest FORMS)
  `(lambda ,(--filter (s-contains? (symbol-name it)
                                   (prin1-to-string FORMS))
                      &#39;(x1 x2 x3 x4 x5))
     ,FORMS))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This enables:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;
(funcall (xi print (concat x2 x1)) &amp;quot;there&amp;quot; &amp;quot;hi&amp;quot;)
;; expands to
(funcall (lambda (x1 x2) (print (concat x2 x1))) &amp;quot;there&amp;quot; &amp;quot;hi&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This implementation could be improved - the above example works with &lt;code&gt;(xi x3 x1)&lt;/code&gt;,
it doesn&#39;t actually validate that the xi are contiguous. It also doesn&#39;t cover
all numbers of arguments, though over 5 arguments would be questionable anyway.
Lastly it does not distinguish xis as part of say strings.&lt;/p&gt;

&lt;p&gt;This macro is especially useful for lambdas without arguments, like adding hooks
and keybindings.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lisp&#34;&gt;
(add-hook &#39;eshell-exit-hook (lambda () (setq esh-prompt-num 0)))
;; Becomes
(add-hook &#39;eshell-exit-hook (xi setq esh-prompt-num 0))
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>

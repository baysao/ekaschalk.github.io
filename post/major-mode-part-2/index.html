<!DOCTYPE html>
<html lang="en-us">
<head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="theme" content="hugo-academic">
  <meta name="generator" content="Hugo 0.22-DEV" />
  <meta name="author" content="Eric Kaschalk">
  

  
  
  
    
  
  
    
    
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/styles/zenburn.min.css">
    
  
  
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha512-6MXa8B6uaO18Hid6blRMetEIoPqHf7Ux1tnyIQdpt9qI5OACx7C+O3IVTr98vwGnlcg0LOLa02i9Y1HpVhlfiw==" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.8.0/css/academicons.min.css" integrity="sha512-GGGNUPDhnG8LEAEDsjqYIQns+Gu8RBs4j5XGlxl7UfRaZBhCCm5jenJkeJL8uPuOXGqgl8/H1gjlWQDRjd3cUQ==" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha512-SfTiTlX6kk+qitfevl/7LibUOeJWlt9rbyDn92a1DqWOw9vWG2MFoays0sgObmWazO5BQPiFucnnEAjpAB+/Sw==" crossorigin="anonymous">
  
  
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:400,700%7CMerriweather%7CRoboto+Mono">
  <link rel="stylesheet" href="/css/hugo-academic.css">
  
  <link rel="stylesheet" href="/css/custom.css">
  

  
    <script>
      window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
      ga('create', 'UA-101190730-1', 'auto');
      ga('require', 'eventTracker');
      ga('require', 'outboundLinkTracker');
      ga('require', 'urlChangeTracker');
      ga('send', 'pageview');
    </script>
    <script async src="//www.google-analytics.com/analytics.js"></script>
    
    <script async src="https://cdnjs.cloudflare.com/ajax/libs/autotrack/2.4.1/autotrack.js" integrity="sha512-HUmooslVKj4m6OBu0OgzjXXr+QuFYy/k7eLI5jdeEy/F4RSgMn6XRWRGkFi5IFaFgy7uFTkegp3Z0XnJf3Jq+g==" crossorigin="anonymous"></script>
    
  

  <link rel="alternate" href="https://ekaschalk.github.io/index.xml" type="application/rss+xml" title="Modern Emacs">
  <link rel="feed" href="https://ekaschalk.github.io/index.xml" type="application/rss+xml" title="Modern Emacs">

  <link rel="icon" type="image/png" href="/img/icon.png">
  <link rel="apple-touch-icon" type="image/png" href="/img/apple-touch-icon.png">

  <link rel="canonical" href="https://ekaschalk.github.io/post/major-mode-part-2/">

  

  <title>Deep diving into a major mode - Part 2 (IDE Features) | Modern Emacs</title>

</head>
<body id="top" data-spy="scroll" data-target="#navbar-main" data-offset="71">

<nav class="navbar navbar-default navbar-fixed-top" id="navbar-main">
  <div class="container">

    
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse"
              data-target=".navbar-collapse" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="/">Modern Emacs</a>
    </div>

    
    <div class="collapse navbar-collapse">

      
      <ul class="nav navbar-nav navbar-right">
        

        

        <li class="nav-item">
          <a href="/#posts">
            
            <span>Posts</span>
          </a>
        </li>

        
        

        

        <li class="nav-item">
          <a href="/#spacemacs">
            
            <span>My Spacemacs</span>
          </a>
        </li>

        
        

        

        <li class="nav-item">
          <a href="/#about">
            
            <span>About</span>
          </a>
        </li>

        
        

        
      </ul>

    </div>
  </div>
</nav>


<article class="article" itemscope itemtype="http://schema.org/Article">

  


  <div class="article-container">
    <h1 itemprop="name">Deep diving into a major mode - Part 2 (IDE Features)</h1>
    

<div class="article-metadata">

  <span class="article-date">
    <time datetime="2017-10-29 00:00:00 &#43;0000 UTC" itemprop="datePublished">
      <i class="fa fa-calendar"></i>
      Sun, Oct 29, 2017
    </time>
  </span>

  
  
  
  <span class="article-categories">
    <i class="fa fa-tags"></i>
    
    <a href="/categories/emacs">emacs</a
    >
    
  </span>
  
  

  
  
<div class="share-box" aria-hidden="true">
  <ul class="share">
    <li>
      <a class="facebook"
         href="https://www.facebook.com/sharer.php?u=https%3a%2f%2fekaschalk.github.io%2fpost%2fmajor-mode-part-2%2f"
         target="_blank">
        <i class="fa fa-facebook"></i>
      </a>
    </li>
    <li>
      <a class="twitter"
         href="https://twitter.com/intent/tweet?text=Deep%20diving%20into%20a%20major%20mode%20-%20Part%202%20%28IDE%20Features%29&amp;url=https%3a%2f%2fekaschalk.github.io%2fpost%2fmajor-mode-part-2%2f"
         target="_blank">
        <i class="fa fa-twitter"></i>
      </a>
    </li>
    <li>
      <a class="linkedin"
         href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fekaschalk.github.io%2fpost%2fmajor-mode-part-2%2f&amp;title=Deep%20diving%20into%20a%20major%20mode%20-%20Part%202%20%28IDE%20Features%29"
         target="_blank">
        <i class="fa fa-linkedin"></i>
      </a>
    </li>
    <li>
      <a class="weibo"
         href="http://service.weibo.com/share/share.php?url=https%3a%2f%2fekaschalk.github.io%2fpost%2fmajor-mode-part-2%2f&amp;title=Deep%20diving%20into%20a%20major%20mode%20-%20Part%202%20%28IDE%20Features%29"
         target="_blank">
        <i class="fa fa-weibo"></i>
      </a>
    </li>
    <li>
      <a class="email"
         href="mailto:?subject=Deep%20diving%20into%20a%20major%20mode%20-%20Part%202%20%28IDE%20Features%29&amp;body=https%3a%2f%2fekaschalk.github.io%2fpost%2fmajor-mode-part-2%2f">
        <i class="fa fa-envelope"></i>
      </a>
    </li>
  </ul>
</div>


  

</div>

    <div class="article-style" itemprop="articleBody">
      <p>In <a href='/post/major-mode-part-1/'>Part 1</a> I addressed:
syntax tables, indentation, font locking, and context-sensitive syntax.</p>

<p>We now build out a "Hyde" with: shell/async process integration, Eldoc support,
and Autocompletion. Also "shift-K" documentation lookup for the symbol-at-point.</p>

<p><img src="/img/eldoc-auto.png" alt="/img/eldoc-auto.png" title="/img/eldoc-auto.png" /></p>

<h1 id="building-inferior-hy">Building Inferior Hy</h1>

<h2 id="the-basics">The basics</h2>

<p>The easiest way to add a REPL to your major-mode is through setting the variable
   <code>inferior-lisp-program</code>, possibly adding setup code through
   <code>inferior-lisp-load-command</code>, then running the <code>inferior-lisp</code> command.</p>

<pre><code class="language-lisp">
;; within the define-derived-mode hy-mode setup...
(setq-local inferior-lisp-program &quot;hy&quot;)
(setq-local inferior-lisp-load-command &quot;(print \&quot;Hy there!\&quot;)&quot;)
</code></pre>

<p>This isn't sufficient for advanced shells. The custom is to create a
    function named <code>run-hy</code> (eg. there is <code>run-python</code>, <code>run-haskell</code>...)
    which starts up the shell, sets <code>inferior-hy-mode</code> , and switches to the
    shell.</p>

<h2 id="comint-mode">Comint-mode</h2>

<p>It is a "Major mode for interacting with an inferior interpreter". Most-all
   inferior modes will derive from <code>comint-mode</code>. It provides many utilities for
   interacting with shell-like processes.</p>

<p>Hy mode's prompt is a right arrow.</p>

<pre><code class="language-lisp">
(define-derived-mode inferior-hy-mode comint-mode &quot;Inferior Hy&quot;
  &quot;Major mode for Hy inferior process.&quot;
  (setq-local indent-tabs-mode nil)

  ;; How to dispaly the process status in the mode-line
  (setq mode-line-process '(&quot;:%s&quot;))
  ;; This disables editing and traversing the &quot;=&gt;&quot; prompts
  (setq-local comint-prompt-read-only t)
  ;; Lets comint mode recognize the prompt
  (setq-local comint-prompt-regexp (rx bol &quot;=&gt;&quot; space))

  ;; ... other specialized config introduced later ...
  )
</code></pre>

<p>There are several comint components we will make use of:</p>

<ol>
<li><code>comint-last-prompt</code> - a cons cell of begin/end markers of last prompt.</li>
<li><code>comint-send-string</code> - perform <code>process-send-string</code> with comint</li>
      bookkeeping.
<li><code>comint-redirect-send-command-to-process</code> and <code>comint-redirect-completed</code> - for sending strings asynchronously.</li>
<li><code>comint-(pre)output-filter-functions</code> - entry points into capturing and</li>
      cleaning process output.
<li><code>make-comint-in-buffer</code> - entry point into comint mode.</li>
</ol>

<h2 id="managing-buffers-and-processes">Managing buffers and processes</h2>

<p>We must manage: the standard hy shell process, the internal hy process used
   for autocompletion and eldoc, and temporal buffers for more advanced buffer
   transformations of the standard hy shell process.</p>

<p>The configuration required of <code>inferior-hy-mode</code> :</p>

<pre><code class="language-lisp">
;;; Configuration

(defconst hy-shell-interpreter &quot;hy&quot;
  &quot;Default Hy interpreter name.&quot;)

(defvar hy-shell-interpreter-args &quot;--spy&quot;
  &quot;Default arguments for Hy interpreter.&quot;)

;;; Internal

(defconst hy-shell-buffer-name &quot;Hy&quot;
  &quot;Default buffer name for Hy interpreter.&quot;)

(defconst hy-shell-internal-buffer-name &quot;Hy Internal&quot;
  &quot;Default buffer name for the internal Hy process.&quot;)

(defvar hy-shell-buffer nil
  &quot;The current shell buffer for Hy.&quot;)

(defvar hy--shell-output-filter-in-progress nil
  &quot;Whether we are waiting for output in `hy-shell-send-string-no-output'.&quot;)

(defvar hy--shell-font-lock-enable t
  &quot;Whether the shell should font-lock the current line.&quot;)
</code></pre>

<p>Now the building blocks of the shell can be defined.</p>

<p>The implementations are rather straightforward. To keep space down, only
    name and docstring are provided:</p>

<pre><code class="language-lisp">
(defun hy--shell-format-process-name (proc-name)
  &quot;Format a PROC-NAME with closing astericks.&quot;)

(defun hy-shell-get-process (&amp;optional internal)
  &quot;Get process corr. to `hy-shell-buffer-name'/`hy-shell-internal-buffer-name'.&quot;)

(defun hy--shell-current-buffer-process ()
  &quot;Get process associated with current buffer.&quot;)

(defun hy--shell-current-buffer-a-process? ()
  &quot;Is `current-buffer' a live process?&quot;)

(defun hy--shell-get-or-create-buffer ()
  &quot;Get or create `hy-shell-buffer' buffer for current hy shell process.&quot;)

(defun hy--shell-buffer? ()
  &quot;Is `hy-shell-buffer' set and does it exist?&quot;)

(defun hy--shell-kill-buffer ()
  &quot;Kill `hy-shell-buffer'.&quot;)

(defun hy--shell-calculate-command (&amp;optional internal)
  &quot;Calculate the string used to execute the inferior Hy process.&quot;)
  ;; Straightforward string formatting - see: `shell-quote-argument'
</code></pre>

<h2 id="starting-up-the-shell">Starting up the shell</h2>

<p>The commands above are enough to build out some basic shell support. Lets
   look at <code>run-hy</code> :</p>

<pre><code class="language-lisp">
(defun run-hy (&amp;optional cmd)
  &quot;Run an inferior Hy process.

CMD defaults to the result of `hy--shell-calculate-command'.&quot;
  (interactive)
  (unless (executable-find &quot;hy&quot;)
    (message &quot;Hy not found, activate a virtual environment with Hy.&quot;))

  (-&gt; (or cmd (hy--shell-calculate-command))
     (hy--shell-make-comint hy-shell-buffer-name 'show)
     get-buffer-process))
</code></pre>

<p>Most of the work is delegated to <code>hy--shell-make-comint</code> as we also must
    have the internal variant:</p>

<pre><code class="language-lisp">
(defun run-hy-internal ()
  &quot;Start an inferior hy process in the background for autocompletion.&quot;
  (interactive)
  (unless (executable-find &quot;hy&quot;)
    (message &quot;Hy not found, activate a virtual environment containing Hy to use
Eldoc, Anaconda, and other hy-mode features.&quot;))

  (when (and (not (hy-shell-get-process 'internal))
             (executable-find &quot;hy&quot;))
    (-let [hy--shell-font-lock-enable
           nil]
      (prog1
          (-&gt; (hy--shell-calculate-command 'internal)
             (hy--shell-make-comint hy-shell-internal-buffer-name nil 'internal)
             get-buffer-process)
        (hy--shell-send-internal-setup-code)
        (message &quot;Hy internal process successfully started&quot;)))))
</code></pre>

<p>This is a simple variation of <code>run-hy</code> that passes the internal argument
    through the hy shell building blocks and also sends setup code for
    <code>eldoc-mode</code> and <code>company-mode</code>.</p>

<p>Now we are ready to startup our <code>inferior-hy-mode</code> :</p>

<pre><code class="language-lisp">
(defun hy--shell-make-comint (cmd proc-name &amp;optional show internal)
  &quot;Create and return comint process PROC-NAME with CMD, opt. INTERNAL and SHOW.&quot;
  (-when-let* ((proc-buffer-name
                (hy--shell-format-process-name proc-name))
               (_
                (not (comint-check-proc proc-buffer-name)))
               (cmdlist
                (split-string-and-unquote cmd))
               (buffer
                (apply 'make-comint-in-buffer proc-name proc-buffer-name
                       (car cmdlist) nil (cdr cmdlist)))
               (process
                (get-buffer-process buffer)))
    (with-current-buffer buffer
      (inferior-hy-mode))
    (when show
      (display-buffer buffer))
    (if internal
        (set-process-query-on-exit-flag process nil)
      (setq hy-shell-buffer buffer))
    proc-buffer-name))
</code></pre>

<p>All the work is once again delegated to our shell building blocks. There are
    several things to notice:</p>

<ol>
<li>If the process is meant to be autostarted/quited, make sure to use <code>set-process-query-on-exit-flag</code> to nil.</li>
<li>The <code>cmdlist</code> car is "hy" and cdr is the hy interpreter arguments.</li>
<li>Further accessing of the shell is done with the <code>hy-shell-buffer</code> variable.</li>
</ol>

<h2 id="working-with-the-shell">Working with the shell</h2>

<p>The shell is now functional, but we still don't have methods to send strings
   to the shell (for instance, sending the current-form or the buffer for
   evaluation). Nor do we have any support for asynchronously sending and
   extracting information from our internal process.</p>

<p>Like always, lets define some utilities:</p>

<pre><code class="language-lisp">
(defun hy--shell-end-of-output? (string)
  &quot;Return non-nil if STRING ends with the prompt.&quot;
  (s-matches? comint-prompt-regexp string))

(defun hy--shell-output-filter (string)
  &quot;If STRING ends with input prompt then set filter in progress done.&quot;
  (when (hy--shell-end-of-output? string)
    (setq hy--shell-output-filter-in-progress nil))
  &quot;\n=&gt; &quot;)
</code></pre>

<p><code>hy--shell-output-filter-in-progress</code> is the critical component. Lets see how
    it is used:</p>

<pre><code class="language-lisp">
(defun hy--shell-send-string (string &amp;optional process internal)
  &quot;Internal implementation of shell send string functionality.&quot;
  (let ((process (or process (hy-shell-get-process internal)))
        (hy--shell-output-filter-in-progress t))
    (comint-send-string process string)
    (while hy--shell-output-filter-in-progress
      (accept-process-output process))))
</code></pre>

<p>The shell process is obtained, we set it to be in progress, and send it off
    to comint. But how and when is the filter reset?</p>

<p>We come back to the <code>comint-(pre)output-filter-functions</code>. When we send the
    string via <code>comint-send-string</code>, part of its bookkeeping is to apply these
    filter functions to the output. However, the output can come in chunks, so
    simply accepting the process output is not sufficient. We must recognize
    when the last of the expected process output is retrieved and signal to stop
    accepting output.</p>

<p>The difference between the pre and standard filters is when they are
    applied. The pre variation is executed before the process output is inserted
    into the buffer.</p>

<p>Looking back to <code>hy--shell-output-filter</code>, what are the outcomes of using it
    as a pre or standard filter? Lets look at the exposed send strings:</p>

<pre><code class="language-lisp">
(defun hy-shell-send-string-no-output (string &amp;optional process internal)
  &quot;Send STRING to hy PROCESS and inhibit printing output.&quot;
  (-let [comint-preoutput-filter-functions
         '(hy--shell-output-filter)]
    (hy--shell-send-string string process internal)))

(defun hy-shell-send-string (string &amp;optional process)
  &quot;Send STRING to hy PROCESS.&quot;
  (-let [comint-output-filter-functions
         '(hy--shell-output-filter)]
    (hy--shell-send-string string process)))
</code></pre>

<p>Lastly, these functions won't work for asynchronous ops like Eldoc and
    Autocompletion. You will see a <code>Blocking call inhibiting process output</code> error messaged in the minibuffer.</p>

<p>The asynchronous version is different. We redirect the process output to a
    temporary buffer and capture its output.</p>

<p>The key is the 100ms <code>timeout</code> argument passed to <code>accept-process-output</code>.</p>

<pre><code class="language-lisp">
(defun hy--shell-send-async (string)
  &quot;Send STRING to internal hy process asynchronously.&quot;
  (let ((output-buffer &quot; *Comint Hy Redirect Work Buffer*&quot;)
        (proc (hy-shell-get-process 'internal)))
    (with-current-buffer (get-buffer-create output-buffer)
      (erase-buffer)
      (comint-redirect-send-command-to-process string output-buffer proc nil t)

      (set-buffer (process-buffer proc))
      (while (and (null comint-redirect-completed)
                  (accept-process-output proc nil 100 t)))
      (set-buffer output-buffer)
      (buffer-string))))
</code></pre>

<p>Our shell is now ready for autocompletion, eldoc, and other awesome IDE features.</p>

<p>I originally planned to go into font-locking the prompt input (highly
    non-trivial), but given the length of this post I will provide and link to
    it as a separate future post.</p>

<h1 id="autocompletion">Autocompletion</h1>

<p>All the work for autocompletion was in setting up the asynchronous process
  support. Lets see how easy autocompletion becomes:</p>

<pre><code class="language-lisp">
(defconst hy-company-setup-code
  &quot;(import [hy.completer [Completer]])
(setv --HYCOMPANY (Completer))&quot;
  &quot;Autocompletion setup code to send to the internal process.&quot;)

(defconst hy--company-regexp
  (rx &quot;'&quot;
      (group (1+ (not (any &quot;,]&quot;))))
      &quot;'&quot;
      (any &quot;,&quot; &quot;]&quot;))
  &quot;Regex to extra candidates from --HYCOMPANY.&quot;)

(defun hy--company-format-str (string)
  &quot;Format STRING to send to hy for completion candidates.&quot;
  (when string
    (format &quot;(.%s --HYCOMPANY \&quot;%s\&quot;)&quot;
            (cond ((s-starts-with? &quot;#&quot; string)  ; Tag matches broken in Hy atm
                   &quot;tag-matches&quot;)
                  ((s-contains? &quot;.&quot; string)
                   &quot;attr-matches&quot;)
                  (t
                   &quot;global-matches&quot;))
            string)))

(defun hy--company-candidates (string)
  &quot;Get candidates for completion of STRING.&quot;
  (-when-let* ((command (hy--company-format-str string))
               (candidates (hy--shell-send-async command))
               (matches (s-match-strings-all hy--company-regexp candidates)))
    (-select-column 1 matches)))  ; Get match-data-1 for each match

(defun company-hy (command &amp;optional arg &amp;rest ignored)
  (interactive (list 'interactive))
  (cl-case command
    (prefix (company-grab-symbol))
    (candidates (hy--company-candidates arg))
    (meta (-&gt; arg hy--eldoc-get-docs hy--str-or-empty))))
</code></pre>

<p><code>Completer</code> is a hy builtin that completes a given string and does all the
    work here. We simply call it's appropriate method, extract the items in the
    retrieved list, and hand it off to company.</p>

<p><code>company-grab-symbol</code> gets the current symbol which is handed off as <code>arg</code> in
    the subsequent call.</p>

<p>The <code>meta</code> argument shows the eldoc output for the current selected company
    candidate in the minibuffer, as seen in this post's initial image.</p>

<p><code>company-hy</code> can then be enabled either through adding to <code>company-backends</code> or
    for Spacemacs users adding:</p>

<pre><code class="language-lisp">
;; Technically this should be within a hy layer, but this still works uncaptured
(spacemacs|add-company-backends
  :backends company-hy
  :modes hy-mode inferior-hy-mode)
</code></pre>

<p>Developing a major-mode that accommodates Spacemacs users will be touched on
    in future posts.</p>

<h1 id="eldoc">Eldoc</h1>

<p>For those unfamiliar, in the initial image <code>eldoc-mode</code> provides the formatted
  docstring and arguments in the minibuffer for the symbol-at-point (or
  completion candidate).</p>

<p>Perhaps surprisingly, Eldoc is <em>a lot</em> more challenging than autocompletion.</p>

<p>For starters, your language won't provide Eldoc like strings (formatted
  argument list + first line of docstring) by default. How difficult inspecting
  language constructs is entirely dependent on the language. Hy in particular is
  difficult due to how macros are implemented and namespaced. I won't provide
  the <code>hy-eldoc-setup-code</code> here, it can be found within the source.</p>

<p>Next, your implementation must mirror any relevant DSLs. For lisps, Eldoc
  inspects the form opener. It is hydiomatic to:</p>

<pre><code class="language-lisp">
(setv x &quot;hi&quot;)
(.format &quot;{} there&quot; x)
(setv a-list [])
(.append a-list &quot;friend&quot;)
</code></pre>

<p>We need to send <code>str.format</code> and <code>a-list.append</code> - the form opener alone is
  insufficient.</p>

<h2 id="implementation">Implementation</h2>

<p>Eldoc is setup via the <code>eldoc-documentation-function</code> :</p>

<pre><code class="language-lisp">
(defun hy-eldoc-documentation-function ()
  &quot;Drives `eldoc-mode', retrieves eldoc msg string for inner-most symbol.&quot;
  (-&gt; (hy--eldoc-get-inner-symbol)
     hy--eldoc-get-docs))

(defun hy--mode-setup-eldoc ()
  (make-local-variable 'eldoc-documentation-function)
  (setq-local eldoc-documentation-function 'hy-eldoc-documentation-function)
  (eldoc-mode +1))
</code></pre>

<p>There are three core components:</p>

<ol>
<li><code>hy--eldoc-send</code> for sending a formatted string and cleaning its output.</li>
<li><code>hy--eldoc-get-inner-symbol</code> getting opening form and completing the dot DSL.</li>
<li><code>hy--eldoc-fontify-text</code> for highlighting the final text string like in the image.</li>
</ol>

<p>Lets look at fontifying first. We can't blindly apply Hy's font-locks as the
   docstring isn't captured in quotes. Since the text is static, we just add the
   faces to the string ourselves.</p>

<pre><code class="language-lisp">
(defun hy--fontify-text (text regexp &amp;rest faces)
  &quot;Fontify portions of TEXT matching REGEXP with FACES.&quot;
  (when text
    (-each
        (s-matched-positions-all regexp text)
      (-lambda ((beg . end))
        (--each faces
          (add-face-text-property beg end it nil text))))))

(defun hy--eldoc-fontify-text (text)
  &quot;Fontify eldoc TEXT.&quot;
  (let ((kwd-rx
         (rx string-start (1+ (not (any space &quot;:&quot;))) &quot;:&quot;))
        (kwargs-rx
         (rx symbol-start &quot;&amp;&quot; (1+ word)))
        (quoted-args-rx
         (rx &quot;`&quot; (1+ (not space)) &quot;`&quot;)))
    (hy--fontify-text
     text kwd-rx 'font-lock-keyword-face)
    (hy--fontify-text
     text kwargs-rx 'font-lock-type-face)
    (hy--fontify-text
     text quoted-args-rx 'font-lock-constant-face 'bold-italic))
  text)
</code></pre>

<p>Next lets see the sending and formatting of the shell's raw eldoc output.</p>

<pre><code class="language-lisp">
(defun hy--eldoc-send (string)
  &quot;Send STRING for eldoc to internal process returning output.&quot;
  (-&gt; string
     hy--shell-send-async
     hy--eldoc-chomp-output
     hy--eldoc-remove-syntax-errors
     hy--str-or-nil))
</code></pre>

<p>The string/output formatting are implementation details specific to Hy and so
   won't be detailed. If we are dealing with an empty string, we return nil
   rather than the empty string to pass-by parent <code>when</code> clauses.</p>

<p>The meat of Eldoc is in extracting the innermost symbol of the current point</p>

<pre><code class="language-lisp">
(defun hy--eldoc-get-inner-symbol ()
  &quot;Traverse and inspect innermost sexp and return formatted string for eldoc.&quot;
  (save-excursion
    (-when-let* ((_ (hy-shell-get-process 'internal))
                 (state (syntax-ppss))
                 (start-pos (hy--sexp-inermost-char state))
                 (_ (progn (goto-char start-pos)
                           (not (hy--not-function-form-p))))
                 (function (progn (forward-char)
                                  (thing-at-point 'symbol))))

      ;; Attribute method call (eg. &quot;.format str&quot;) needs following sexp
      (if (s-starts-with? &quot;.&quot; function)
          (when (ignore-errors (forward-sexp) (forward-char) t)
            (pcase (char-after)
              ;; Can't send just .method to eldoc
              (?\) (setq function nil))
              (?\s (setq function nil))
              (?\C-j (setq function nil))  ; newline

              ;; Dot dsl doesn't work on literals
              (?\[ (concat &quot;list&quot; function))
              (?\{ (concat &quot;dict&quot; function))
              (?\  (concat &quot;str&quot; function))  ; the &quot; is deleted in blog as breaks rainbow.js

              ;; Otherwise complete the dot dsl
              (_ (progn
                   (forward-char)
                   (concat (thing-at-point 'symbol) function)))))
        function))))
</code></pre>

<p>So Eldoc's path is to call <code>hy--eldoc-get-inner-symbol</code> if an internal process
   is active, <code>syntax-ppss</code> indicates we are within a form, and that the
   innermost form is a symbol. The completed string is sent off to the internal
   process we've built up, the output is chomped of quote characters and the
   prompt and syntax errors (eg. completing "str." while we are still typing)
   are ignored. The result is fontified and returned by the documentation function.</p>

<h2 id="spacemacs-shift-k-documentation-lookup">Spacemacs shift-k documentation lookup</h2>

<p>A feature of Spacemacs is typing "K" to perform
   <code>spacemacs/evil-smart-doc-lookup</code> to get the full documentation of the
   symbol-at-point in a separate buffer.</p>

<p>Using Eldoc's documentation functions, with slightly different formatting, we
   already have most of shift-K implemented.</p>

<p>We moved most of <code>hy-eldoc-documentation-function</code> into <code>hy--eldoc-get-docs</code> which
   distinctly accepts an optional argument for buffer-style rather than
   eldoc-style formatting.</p>

<p>We then create a mirror of the documentation function as
   <code>hy--docs-for-thing-at-point</code>. We format the text to account for newlines
   (newlines from process output are escaped so we must trim one backslash from
   each newline).</p>

<pre><code class="language-lisp">
(defun hy--docs-for-thing-at-point ()
  &quot;Mirrors `hy-eldoc-documentation-function' formatted for a buffer, not a msg.&quot;
  (-&gt; (thing-at-point 'symbol)
     (hy--eldoc-get-docs t)
     hy--format-docs-for-buffer))

(defun hy--format-docs-for-buffer (text)
  &quot;Format raw hydoc TEXT for inserting into hyconda buffer.&quot;
  (when text
    (-let [kwarg-newline-regexp
           (rx &quot;,&quot;
               (1+ (not (any &quot;,&quot; &quot;)&quot;)))
               (group-n 1 &quot;\\\n&quot;)
               (1+ (not (any &quot;,&quot; &quot;)&quot;))))]
      (--&gt; text
         (s-replace &quot;\\n&quot; &quot;\n&quot; it)
         (replace-regexp-in-string kwarg-newline-regexp &quot;newline&quot; it nil t 1)))))
</code></pre>

<p>It is interesting how "K" is actually called, I'm not sure if any other
   function operates quite the same. "K" calls the function bound to "SPC m h h".</p>

<pre><code class="language-lisp">
(spacemacs/set-leader-keys-for-major-mode 'hy-mode
  &quot;hh&quot; 'hy-describe-thing-at-point)
</code></pre>

<p>Lastly we need to create, switch-to, and insert the retrieved docs as <code>hy-describe-thing-at-point</code>.</p>

<pre><code class="language-lisp">
(defun hy-describe-thing-at-point ()
  &quot;Implement shift-k docs lookup for `spacemacs/evil-smart-doc-lookup'.&quot;
  (interactive)
  (-when-let* ((text (hy--docs-for-thing-at-point))
               (doc-buffer &quot;*Hyconda*&quot;))
    (with-current-buffer (get-buffer-create doc-buffer)
      (erase-buffer)
      (switch-to-buffer-other-window doc-buffer)

      (insert text)
      (goto-char (point-min))
      (forward-line)

      (insert &quot;------\n&quot;)
      (fill-region (point) (point-max))

      ;; Eventually make hyconda-view-minor-mode, atm this is sufficient
      (local-set-key &quot;q&quot; 'quit-window)
      (when (fboundp 'evil-local-set-key)
        (evil-local-set-key 'normal &quot;q&quot; 'quit-window)))))
</code></pre>

<h1 id="closing">Closing</h1>

<p>There are several other features worth discussion like font-locking the
  shell prompt input and the <code>send-(form/region/buffer)-to-shell</code> that are
  sizable enough to warrant their own posts later. With this post, the series is
  caught up to the current featureset. Linting would be the next big problem to
  attack. I'd also like to integrate <code>ert</code>.</p>

<p>Going without Company and Eldoc has helped me appreciate the value in IDEs.
  Hy is quickly becoming a pleasant development experience.</p>

<p>My only guidance was source code. I hope this series make the problem more
  tractable for prospective major mode authors.</p>

    </div>
  </div>

</article>

<div class="container">
  <nav>
  <ul class="pager">
    
    <li class="previous"><a href="https://ekaschalk.github.io/post/lig-spacing/"><span
      aria-hidden="true">&larr;</span> Solving ligature spacing in Emacs - proof of concept</a></li>
    

    
  </ul>
</nav>

</div>

<div class="article-container">
  
<section id="comments">
  <div id="disqus_thread">
    <div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'ekaschalk-github-io';
    var disqus_identifier = 'https:\/\/ekaschalk.github.io\/post\/major-mode-part-2\/';
    var disqus_title = 'Deep diving into a major mode - Part 2 (IDE Features)';
    var disqus_url = 'https:\/\/ekaschalk.github.io\/post\/major-mode-part-2\/';

    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
  </div>
</section>


</div>

<footer class="site-footer">
  <div class="container">
    <p class="powered-by">

      &copy; 2017 Eric Kaschalk &middot; 

      Powered by the <a href="https://github.com/gcushen/hugo-academic" target="_blank">Academic
      theme</a> for <a href="http://gohugo.io" target="_blank">Hugo</a>.

      <span class="pull-right" aria-hidden="true">
        <a href="#" id="back_to_top">
          <span class="button_icon">
            <i class="fa fa-chevron-up fa-2x"></i>
          </span>
        </a>
      </span>

    </p>
  </div>
</footer>

    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.12.4/jquery.min.js" integrity="sha512-jGsMH83oKe9asCpkOVkBnUrDDTp8wl+adkB2D+//JtlxO4SrLoJdhbOysIFQJloQFD+C4Fl1rMsQZF76JjV0eQ==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.imagesloaded/4.1.2/imagesloaded.pkgd.min.js" integrity="sha512-iHzEu7GbSc705hE2skyH6/AlTpOfBmkx7nUqTLGzPYR+C1tRaItbRlJ7hT/D3YQ9SV0fqLKzp4XY9wKulTBGTw==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/1.19.1/TweenMax.min.js" integrity="sha512-Z5heTz36xTemt1TbtbfXtTq5lMfYnOkXM2/eWcTTiLU01+Sw4ku1i7vScDc8fWhrP2abz9GQzgKH5NGBLoYlAw==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/1.19.1/plugins/ScrollToPlugin.min.js" integrity="sha512-CDeU7pRtkPX6XJtF/gcFWlEwyaX7mcAp5sO3VIu/ylsdR74wEw4wmBpD5yYTrmMAiAboi9thyBUr1vXRPA7t0Q==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha512-iztkobsvnjKfAtTNdHkGVjAYTrrtlC7mGp/54c40wowO7LhURYl3gVzzcEqGl/qKXQltJ2HwMrdLcNUdo+N/RQ==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.isotope/3.0.4/isotope.pkgd.min.js" integrity="sha512-VDBOIlDbuC4VWxGJNmuFRQ0Li0SKkDpmGyuhAG5LTDLd/dJ/S0WMVxriR2Y+CyPL5gzjpN4f/6iqWVBJlht0tQ==" crossorigin="anonymous"></script>
    
    <script src="/js/hugo-academic.js"></script>
    
    <script src="/js/custom.js"></script>
    

    
    
      
      <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/highlight.min.js"></script>

      
      <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/languages/python.min.js"></script>
      
      <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/languages/lisp.min.js"></script>
      
      <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/languages/hy.min.js"></script>
      
      <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/languages/clojure.min.js"></script>
      

      

      <script>hljs.initHighlightingOnLoad();</script>
    

    
    

  </body>
</html>

